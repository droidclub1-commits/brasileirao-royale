<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <!-- Configuração crítica para Mobile: Impede zoom e ajusta à tela -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- ... (metatags existentes) ... -->
    <title>Brasileirão Royale</title>
    <!-- Tailwind CSS via CDN (Requer internet para carregar o estilo) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;900&display=swap" rel="stylesheet">
    <script type="module">
        // ... (código firebase existente) ...
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Configuração do Firebase
        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        signInAnonymously(auth).catch(console.error);
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #111827; color: white; overflow: hidden; }
        canvas { touch-action: none; outline: none; -webkit-tap-highlight-color: transparent; }
        
        /* ... (scrollbar styles) ... */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 2px; }

        .safe-area-bottom {
            padding-bottom: env(safe-area-inset-bottom);
        }

        /* --- NOVOS ESTILOS DE TELA CHEIA --- */

        /* Ocultar UI normal em tela cheia */
        :fullscreen #mainHeader,
        :fullscreen #bottomPanel {
            display: none;
        }

        /* Expandir área do jogo em tela cheia */
        :fullscreen #gameArea {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            /* z-index mais baixo para ficar atrás dos modais */
            z-index: 30; 
        }

        /* Mostrar controles de overlay em tela cheia */
        :fullscreen #fullscreenControls {
            display: flex;
        }
    </style>
</head>
<body class="h-screen flex flex-col bg-gray-900 select-none">

    <!-- App Header -->
    <header id="mainHeader" class="bg-gray-900 p-3 border-b border-gray-800 flex justify-between items-center shrink-0 z-20 shadow-lg h-14">
        <!-- ... (logo e rodada) ... -->
        <div class="flex items-center gap-2">
            <div class="w-8 h-8 bg-yellow-500 rounded flex items-center justify-center font-black text-black text-sm shadow-glow">BR</div>
            <div class="flex flex-col">
                <span class="text-[10px] text-gray-400 font-bold uppercase leading-none mb-0.5">Rodada</span>
                <span id="currentRoundDisplay" class="text-sm font-bold text-white leading-none">0/38</span>
            </div>
        </div>
        
        <div class="flex items-center gap-3">
            <!-- NOVO: Botão de Tela Cheia -->
            <button id="fullscreenBtn" class="p-1 text-gray-400 hover:text-white">
                <svg id="icon-open" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                <svg id="icon-close" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>
            </button>
            <div class="text-right">
                 <span class="text-[10px] text-gray-500 block leading-none mb-0.5">TEMPO</span>
                <div id="timerDisplay" class="text-xl font-black font-mono text-white leading-none">01:00</div>
            </div>
        </div>
    </header>

    <!-- Area do Jogo -->
    <div id="gameArea" class="flex-1 relative bg-gray-800 flex flex-col overflow-hidden">
        <!-- Arena (Canvas) -->
        <div class="flex-1 relative w-full bg-gray-900 group">
             <!-- Padrão de fundo sutil -->
             <div class="absolute inset-0 opacity-10 pointer-events-none" style="background-image: radial-gradient(#ffffff 1px, transparent 1px); background-size: 20px 20px;"></div>
            <canvas id="arena" class="w-full h-full block"></canvas>

            <!-- Overlay de Vitória -->
            <div id="roundOverlay" class="absolute inset-0 flex flex-col items-center justify-center bg-black/90 z-30 hidden backdrop-blur-sm p-6 text-center transition-all">
                <!-- IDs Adicionados para controle -->
                <div class="text-xs text-gray-400 uppercase tracking-widest mb-2 font-bold" id="overlaySubTitle">Vencedor da Rodada</div>
                <h2 class="text-5xl font-black text-white mb-2 drop-shadow-lg" id="overlayTitle">TIME</h2>
                <div id="overlayScore" class="text-4xl font-mono text-yellow-400 mt-2 hidden font-bold"></div>
                <p class="text-gray-500 text-xs mt-10 animate-pulse uppercase tracking-widest" id="overlayTapText">Toque para continuar</p>
            </div>
        </div>

        <!-- Controles Flutuantes (Sobrepostos na parte inferior da arena) -->
        <div class="absolute bottom-6 left-0 right-0 px-6 flex justify-center z-20 pointer-events-none">
            <button id="actionBtn" class="pointer-events-auto bg-green-600 text-white w-full shadow-[0_0_20px_rgba(22,163,74,0.5)] py-4 rounded-xl font-black text-sm uppercase tracking-wider active:scale-95 transition-transform border-t border-green-400">
                INICIAR CAMPEONATO
            </button>
        </div>
        
        <!-- NOVOS: Controles de Tela Cheia (Overlay) -->
        <div id="fullscreenControls" class="absolute top-4 right-4 z-40 hidden flex-col gap-2 pointer-events-none">
             <button id="fsBtnClassificacao" class="pointer-events-auto bg-black/60 text-white backdrop-blur-md p-3 rounded-lg shadow-lg text-xs uppercase font-bold">Ver Tabela</button>
             <button id="fsBtnPlayoff" class="pointer-events-auto bg-black/60 text-white backdrop-blur-md p-3 rounded-lg shadow-lg text-xs uppercase font-bold">Ver Mata-Mata</button>
        </div>
    </div>
    
    <!-- NOVO: Modal de Tela Cheia -->
    <div id="fullscreenModal" class="absolute inset-0 bg-gray-900/90 backdrop-blur-md z-50 hidden flex-col p-4 safe-area-bottom">
        <div class="flex-1 overflow-y-auto" id="fullscreenModalContent">
            <!-- Conteúdo será injetado aqui pelo JS -->
        </div>
        <button id="fsBtnCloseModal" class="mt-4 bg-red-600 text-white py-3 rounded-lg font-bold uppercase text-xs tracking-wider">Fechar</button>
    </div>

    <!-- Painel Inferior (Tabs) -->
    <div id="bottomPanel" class="h-[35vh] bg-gray-900 border-t border-gray-800 flex flex-col shrink-0 safe-area-bottom z-30 shadow-[0_-5px_15px_rgba(0,0,0,0.5)]">
        <!-- ... (botões de aba) ... -->
        <div class="flex border-b border-gray-800">
            <button id="tabTable" class="flex-1 py-3 text-[10px] font-bold uppercase bg-gray-800 text-yellow-400 border-b-2 border-yellow-400 transition-colors tracking-widest">Classificação</button>
            <button id="tabPlayoff" class="flex-1 py-3 text-[10px] font-bold uppercase text-gray-500 border-b-2 border-transparent hover:bg-gray-800 transition-colors tracking-widest">Mata-Mata</button>
        </div>

        <div class="flex-1 overflow-y-auto relative bg-gray-900" id="contentArea">
            <!-- Tabela -->
            <div id="leaderboardContainer" class="w-full pb-4">
                <table class="w-full text-sm text-left">
                    <thead class="text-[10px] text-gray-500 uppercase bg-gray-900 sticky top-0 z-10 shadow-sm">
                        <tr>
                            <th class="px-3 py-2 text-center w-8 bg-gray-900">#</th>
                            <th class="px-2 py-2 bg-gray-900">Clube</th>
                            <th class="px-2 py-2 text-right bg-gray-900">Pts</th>
                            <th class="px-2 py-2 text-center bg-gray-900">V</th>
                        </tr>
                    </thead>
                    <tbody id="leaderboardBody" class="divide-y divide-gray-800"></tbody>
                </table>
            </div>

            <!-- Playoffs -->
            <div id="playoffContainer" class="hidden p-4 space-y-4 pb-16">
                <!-- ID modificado para consistência -->
                <div id="playoffBracket"></div>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURAÇÃO DO APP ---
        // ... (const TEAMS, POINTS, canvas, ctx, state) ...
        const TEAMS = [
            { name: 'Flamengo', color: '#C8102E', text: '#fff', abbr: 'FLA' },
            { name: 'Palmeiras', color: '#006437', text: '#fff', abbr: 'PAL' },
            { name: 'São Paulo', color: '#FE0000', text: '#fff', abbr: 'SPA', stroke: '#fff' },
            { name: 'Atlético-MG', color: '#000000', text: '#fff', abbr: 'CAM', stroke: '#fff' },
            { name: 'Botafogo', color: '#000000', text: '#fff', abbr: 'BOT', stroke: '#fff' },
            { name: 'Grêmio', color: '#0D80BF', text: '#fff', abbr: 'GRE' },
            { name: 'Fluminense', color: '#8A0538', text: '#fff', abbr: 'FLU' },
            { name: 'Internacional', color: '#FF0000', text: '#fff', abbr: 'INT' },
            { name: 'Fortaleza', color: '#113687', text: '#fff', abbr: 'FOR' },
            { name: 'Corinthians', color: '#FFFFFF', text: '#000', abbr: 'COR', stroke: '#000' },
            { name: 'Santos', color: '#FFFFFF', text: '#000', abbr: 'SAN', stroke: '#000' },
            { name: 'Vasco', color: '#000000', text: '#fff', abbr: 'VAS', stroke: '#fff' },
            { name: 'Cruzeiro', color: '#0055A4', text: '#fff', abbr: 'CRU' },
            { name: 'Bahia', color: '#009CA6', text: '#fff', abbr: 'BAH' },
            { name: 'Vitória', color: '#FF0000', text: '#000', abbr: 'VIT', stroke: '#000' },
            { name: 'Juventude', color: '#00913E', text: '#fff', abbr: 'JUV' },
            { name: 'Bragantino', color: '#FFFFFF', text: '#000', abbr: 'RBB', stroke: '#cf0c0c' },
            { name: 'Ceará', color: '#000000', text: '#fff', abbr: 'CEA', stroke: '#fff' },
            { name: 'Sport', color: '#D31522', text: '#ffde00', abbr: 'SPT' },
            { name: 'Mirassol', color: '#FFD700', text: '#006437', abbr: 'MIR' }
        ];

        const POINTS = { 0: 15, 1: 12, 2: 9, 3: 7, 4: 6, 5: 5, 6: 5, 7: 5, 8: 5, 9: 5, 10: 3, 11: 3, 12: 3, 13: 3, 14: 3, 15: 2, 16: 2, 17: 2, 18: 2, 19: 0 };
        const ROUND_DURATION_MS = 60000; 

        const canvas = document.getElementById('arena');
        const ctx = canvas.getContext('2d');
        
        let state = {
            phase: 'SEASON',
            round: 0,
            isRunning: false,
            startTime: 0,
            teams: [],
            balls: [],
            deadStack: [],
            playoff: { bracket: [], matchIdx: 0, scores: [0, 0] },
            zone: { x: 0, y: 0, r: 0, startR: 0 }
        };

        // ... (Classe Ball) ...
        class Ball {
            constructor(team, x, y) {
                this.team = team;
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.alive = true;
                this.hp = 100;
                this.flash = 0;
                this.radius = 14; // Bolas maiores para tela pequena
            }
            update(zone) {
                if (!this.alive) return;
                
                // IA Movimento agressiva
                if (Math.random() < 0.1) {
                    const angle = Math.random() * Math.PI * 2;
                    this.vx += Math.cos(angle) * 0.9;
                    this.vy += Math.sin(angle) * 0.9;
                }
                const dxZone = zone.x - this.x;
                const dyZone = zone.y - this.y;
                const distToZone = Math.hypot(dxZone, dyZone);
                
                if (distToZone > 0) {
                    const urgency = distToZone > zone.r * 0.8 ? 0.18 : 0.03; 
                    this.vx += (dxZone / distToZone) * urgency;
                    this.vy += (dyZone / distToZone) * urgency;
                }

                const speed = Math.hypot(this.vx, this.vy);
                if (speed > 7) {
                    this.vx = (this.vx / speed) * 7;
                    this.vy = (this.vy / speed) * 7;
                }

                this.x += this.vx;
                this.y += this.vy;

                // Paredes
                if (this.x < this.radius) { this.x = this.radius; this.vx *= -0.8; }
                if (this.x > canvas.width - this.radius) { this.x = canvas.width - this.radius; this.vx *= -0.8; }
                if (this.y < this.radius) { this.y = this.radius; this.vy *= -0.8; }
                if (this.y > canvas.height - this.radius) { this.y = canvas.height - this.radius; this.vy *= -0.8; }

                // Gás
                if (distToZone > zone.r) {
                    const elapsed = Date.now() - state.startTime;
                    const damageMultiplier = 1 + (elapsed / ROUND_DURATION_MS);
                    this.hp -= 0.9 * damageMultiplier;
                    this.flash = 0.5;
                }
                if (this.hp <= 0) {
                    this.alive = false;
                    state.deadStack.push(this.team.id);
                }
            }
            draw() {
                if (!this.alive) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Sombra
                ctx.beginPath();
                ctx.arc(2, 2, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.fill();

                // Corpo
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.team.color;
                ctx.fill();
                ctx.strokeStyle = this.team.stroke || 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Texto
                ctx.fillStyle = this.team.text;
                ctx.font = '900 9px "Inter"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.team.abbr, 0, 1);

                // Vida
                const hpPct = Math.max(0, this.hp / 100);
                if (hpPct < 1) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 3, -Math.PI/2, (-Math.PI/2) + (Math.PI*2*hpPct));
                    ctx.strokeStyle = hpPct > 0.3 ? '#4ade80' : '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                if (this.flash > 0) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI*2);
                    ctx.fillStyle = `rgba(255,255,255,${this.flash})`;
                    ctx.fill();
                    this.flash -= 0.1;
                }
                ctx.restore();
            }
        }


        function init() {
            resize();
            window.addEventListener('resize', resize);
            resetCampaign();
            document.getElementById('actionBtn').addEventListener('click', handleAction);
            document.getElementById('tabTable').onclick = () => switchTab('table');
            document.getElementById('tabPlayoff').onclick = () => switchTab('playoff');
            document.getElementById('roundOverlay').addEventListener('click', () => {
                 document.getElementById('roundOverlay').classList.add('hidden');
            }); 
            
            // NOVOS Listeners
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
            document.getElementById('fsBtnClassificacao').addEventListener('click', () => showFullscreenModal('table'));
            document.getElementById('fsBtnPlayoff').addEventListener('click', () => showFullscreenModal('playoff'));
            document.getElementById('fsBtnCloseModal').addEventListener('click', hideFullscreenModal);
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            
            loop();
        }

        // ... (resize, resetCampaign, handleAction, startRound, loop, resolveCollisions, finishRound) ...
        function resize() {
            // Resize correto para o canvas preencher o div pai
            const parent = canvas.parentElement;
            canvas.width = parent.clientWidth;
            canvas.height = parent.clientHeight;
            if (!state.isRunning) drawIdle();
        }

        function resetCampaign() {
            state.teams = TEAMS.map((t, i) => ({ ...t, id: i, points: 0, wins: 0 }));
            state.round = 0;
            state.phase = 'SEASON';
            state.playoff.bracket = [];
            state.isRunning = false;
            updateUI();
            renderLeaderboard();
            drawIdle();
            switchTab('table');
        }

        function handleAction() {
            if (state.isRunning) return;
            
            document.getElementById('roundOverlay').classList.add('hidden');

            if (state.phase === 'SEASON') {
                startRound(state.teams);
            } else {
                const match = state.playoff.bracket[state.playoff.matchIdx];
                startRound([state.teams[match.p1], state.teams[match.p2]]);
            }
        }

        function startRound(roster) {
            if(state.isRunning) return;
            state.isRunning = true;
            state.startTime = Date.now();
            state.balls = [];
            state.deadStack = [];
            state.zone = { 
                x: canvas.width/2, 
                y: canvas.height/2, 
                startR: Math.hypot(canvas.width, canvas.height)/1.4,
                r: 1000 
            };

            const spawnR = Math.min(canvas.width, canvas.height) * 0.30;
            roster.forEach((team, i) => {
                const angle = (i / roster.length) * Math.PI * 2;
                const ball = new Ball(
                    team, 
                    state.zone.x + Math.cos(angle) * spawnR,
                    state.zone.y + Math.sin(angle) * spawnR
                );
                state.balls.push(ball);
            });

            const btn = document.getElementById('actionBtn');
            btn.textContent = "COMBATE EM ANDAMENTO...";
            btn.classList.remove('bg-green-600');
            btn.classList.add('bg-gray-600', 'cursor-not-allowed');
            document.getElementById('roundOverlay').classList.add('hidden');
        }

        function loop() {
            requestAnimationFrame(loop);
            if (!state.isRunning) return;

            const elapsed = Date.now() - state.startTime;
            const progress = Math.min(elapsed / ROUND_DURATION_MS, 1);
            const timeLeft = Math.max(0, Math.ceil((ROUND_DURATION_MS - elapsed) / 1000));
            
            document.getElementById('timerDisplay').innerText = `00:${timeLeft.toString().padStart(2, '0')}`;
            document.getElementById('timerDisplay').className = timeLeft <= 10 ? 'text-xl font-black font-mono text-red-500 animate-pulse' : 'text-xl font-black font-mono text-white';

            state.zone.r = state.zone.startR * (1 - progress);
            if (progress >= 1) state.zone.r = 0;

            // Render
            ctx.fillStyle = '#111827';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawGrid();

            // Zona
            ctx.save();
            ctx.fillStyle = 'rgba(220, 38, 38, 0.2)'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            ctx.arc(state.zone.x, state.zone.y, Math.max(0, state.zone.r), 0, Math.PI*2);
            ctx.clip();
            ctx.fillStyle = '#064e3b'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawGrid(0.1);
            ctx.restore();

            ctx.beginPath();
            ctx.arc(state.zone.x, state.zone.y, Math.max(0, state.zone.r), 0, Math.PI*2);
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Physics
            state.balls.forEach(b => b.update(state.zone));
            resolveCollisions();
            state.balls.forEach(b => b.draw());

            const alive = state.balls.filter(b => b.alive);
            if (alive.length <= 1) finishRound(alive[0]);
        }

        function resolveCollisions() {
            const balls = state.balls;
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    if (!balls[i].alive || !balls[j].alive) continue;
                    const b1 = balls[i];
                    const b2 = balls[j];
                    const dx = b2.x - b1.x;
                    const dy = b2.y - b1.y;
                    const dist = Math.hypot(dx, dy);
                    const minDist = b1.radius * 2;

                    if (dist < minDist) {
                        const angle = Math.atan2(dy, dx);
                        const sin = Math.sin(angle), cos = Math.cos(angle);
                        const vx1 = b1.vx * cos + b1.vy * sin;
                        const vy1 = b1.vy * cos - b1.vx * sin;
                        const vx2 = b2.vx * cos + b2.vy * sin;
                        const vy2 = b2.vy * cos - b2.vx * sin;
                        const bounce = 1.05;
                        
                        b1.vx = (vx2 * bounce) * cos - vy1 * sin;
                        b1.vy = (vx2 * bounce) * sin + vy1 * cos;
                        b2.vx = (vx1 * bounce) * cos - vy2 * sin;
                        b2.vy = (vx1 * bounce) * sin + vy2 * cos;

                        const overlap = (minDist - dist) / 2;
                        b1.x -= overlap * Math.cos(angle);
                        b1.y -= overlap * Math.sin(angle);
                        b2.x += overlap * Math.cos(angle);
                        b2.y += overlap * Math.sin(angle);
                        
                        b1.hp -= 2; b2.hp -= 2;
                        b1.flash = 0.3; b2.flash = 0.3;
                    }
                }
            }
        }

        function finishRound(winner) {
            state.isRunning = false;
            
            const winnerId = winner ? winner.team.id : (state.deadStack.length > 0 ? state.deadStack[state.deadStack.length-1] : 0);
            const winnerName = state.teams[winnerId].name;

            if (state.phase === 'SEASON') {
                const rankOrder = [...state.deadStack];
                if(winner) rankOrder.push(winnerId);
                rankOrder.reverse();
                
                rankOrder.forEach((tid, r) => {
                    state.teams[tid].points += (POINTS[r] || 0);
                    if(r === 0) state.teams[tid].wins++;
                });
                
                state.round++;
                renderLeaderboard();
                showOverlay(winnerName, false, null); // Modificado para 3 args
                
                if (state.round >= 38) {
                    initPlayoffs();
                    // Delay alert para não quebrar o fluxo visual
                    setTimeout(() => alert("Fim da Temporada! Iniciando Mata-Mata."), 500);
                }
            } else {
                const match = state.playoff.bracket[state.playoff.matchIdx];
                const isP1 = winnerId === match.p1;
                if (isP1) state.playoff.scores[0]++; else state.playoff.scores[1]++;
                
                const [s1, s2] = state.playoff.scores;
                showOverlay(winnerName, true, `${s1} x ${s2}`); // 3 args, ok
                
                if (s1 === 3 || s2 === 3) {
                    match.winner = s1 === 3 ? match.p1 : match.p2;
                    advancePlayoff();
                }
                renderBracket();
            }
            updateUI();
        }

        // ... (initPlayoffs, advancePlayoff, updateUI) ...
        function initPlayoffs() {
            const sorted = [...state.teams].sort((a,b) => b.points - a.points || b.wins - a.wins);
            const top8 = sorted.slice(0, 8);
            state.playoff.bracket = [
                { round: 'Quartas', p1: top8[0].id, p2: top8[7].id, winner: null },
                { round: 'Quartas', p1: top8[3].id, p2: top8[4].id, winner: null },
                { round: 'Quartas', p1: top8[1].id, p2: top8[6].id, winner: null },
                { round: 'Quartas', p1: top8[2].id, p2: top8[5].id, winner: null },
            ];
            state.playoff.matchIdx = 0;
            state.playoff.scores = [0, 0];
            state.phase = 'PLAYOFFS';
            switchTab('playoff');
        }

        function advancePlayoff() {
            const next = state.playoff.bracket.findIndex(m => !m.winner);
            if (next === -1) {
                const currentR = state.playoff.bracket[state.playoff.bracket.length-1].round;
                const winners = state.playoff.bracket.filter(m => m.round === currentR).map(m => m.winner);
                
                if (winners.length === 1) {
                    setTimeout(() => alert(`CAMPEÃO: ${state.teams[winners[0]].name}!`), 500);
                    return;
                }
                
                const nextRName = currentR === 'Quartas' ? 'Semi' : 'Final';
                for(let i=0; i<winners.length; i+=2) {
                    state.playoff.bracket.push({ round: nextRName, p1: winners[i], p2: winners[i+1], winner: null });
                }
                state.playoff.matchIdx = state.playoff.bracket.length - (winners.length/2);
            } else {
                state.playoff.matchIdx = next;
            }
            state.playoff.scores = [0, 0];
        }

        // UI Helpers
        function updateUI() {
            const btn = document.getElementById('actionBtn');
            const roundTxt = document.getElementById('currentRoundDisplay');
            
            btn.classList.remove('bg-gray-600', 'cursor-not-allowed');
            btn.classList.add('bg-green-600');

            if (state.phase === 'SEASON') {
                btn.textContent = `INICIAR RODADA ${state.round + 1}`;
                roundTxt.textContent = `${state.round}/38`;
            } else {
                const [s1, s2] = state.playoff.scores;
                const match = state.playoff.bracket[state.playoff.matchIdx];
                const t1 = state.teams[match.p1].abbr;
                const t2 = state.teams[match.p2].abbr;
                btn.textContent = `JOGO ${s1+s2+1}: ${t1} v ${t2}`;
                roundTxt.textContent = match.round;
            }
        }
        
        // --- FUNÇÃO showOverlay MODIFICADA ---
        function showOverlay(title, isPlayoff, score, customMessage = null) {
            const el = document.getElementById('roundOverlay');
            const subTitleEl = document.getElementById('overlaySubTitle');
            const titleEl = document.getElementById('overlayTitle');
            const scoreEl = document.getElementById('overlayScore');
            const tapTextEl = document.getElementById('overlayTapText');
            
            titleEl.textContent = title;
            
            if (customMessage) {
                // Modo de Erro
                subTitleEl.textContent = "Aviso";
                scoreEl.classList.add('hidden');
                tapTextEl.textContent = customMessage;
                tapTextEl.classList.remove('animate-pulse'); // Não precisa piscar para um erro
            } else {
                // Modo Normal
                subTitleEl.textContent = "Vencedor da Rodada";
                if (isPlayoff) {
                    scoreEl.textContent = score;
                    scoreEl.classList.remove('hidden');
                } else {
                    scoreEl.classList.add('hidden');
                }
                tapTextEl.textContent = "Toque para continuar";
                tapTextEl.classList.add('animate-pulse');
            }
            
            el.classList.remove('hidden');
        }

        // ... (drawIdle, drawGrid, switchTab) ...
        function drawIdle() {
            ctx.fillStyle = '#064e3b';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawGrid(0.1);
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.beginPath(); ctx.arc(canvas.width/2, canvas.height/2, 60, 0, Math.PI*2); ctx.stroke();
            
            ctx.font = "bold 12px Inter";
            ctx.fillStyle = "rgba(255,255,255,0.4)";
            ctx.textAlign = "center";
            ctx.fillText("PRONTO PARA O COMBATE", canvas.width/2, canvas.height/2 + 80);
        }

        function drawGrid(op=0.05) {
            ctx.strokeStyle = `rgba(255,255,255,${op})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x=0; x<canvas.width; x+=40) { ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
            for(let y=0; y<canvas.height; y+=40) { ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
            ctx.stroke();
        }

        function switchTab(t) {
            const t1 = document.getElementById('leaderboardContainer');
            const t2 = document.getElementById('playoffContainer');
            const b1 = document.getElementById('tabTable');
            const b2 = document.getElementById('tabPlayoff');
            
            if(t === 'table') {
                t1.classList.remove('hidden'); t2.classList.add('hidden');
                b1.classList.add('text-yellow-400', 'border-yellow-400'); b1.classList.remove('text-gray-500', 'border-transparent');
                b2.classList.remove('text-yellow-400', 'border-yellow-400'); b2.classList.add('text-gray-500', 'border-transparent');
            } else {
                t1.classList.add('hidden'); t2.classList.remove('hidden');
                b2.classList.add('text-yellow-400', 'border-yellow-400'); b2.classList.remove('text-gray-500', 'border-transparent');
                b1.classList.remove('text-yellow-400', 'border-yellow-400'); b1.classList.add('text-gray-500', 'border-transparent');
            }
        }


        // --- NOVAS FUNÇÕES DE FULLSCREEN ---

        // --- FUNÇÃO toggleFullscreen MODIFICADA ---
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error(`Erro ao tentar entrar em tela cheia: ${err.message} (${err.name})`);
                    // Mostrar um erro amigável
                    showOverlay("Erro de Permissão", false, null, "O modo tela cheia não é permitido neste ambiente. Tente hospedar o arquivo (via GitHub/Netlify) e abrir no navegador.");
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        function handleFullscreenChange() {
            const iconOpen = document.getElementById('icon-open');
            const iconClose = document.getElementById('icon-close');
            
            if (document.fullscreenElement) {
                // Entrou em FS
                iconOpen.classList.add('hidden');
                iconClose.classList.remove('hidden');
            } else {
                // Saiu do FS
                iconOpen.classList.remove('hidden');
                iconClose.classList.add('hidden');
                hideFullscreenModal(); // Garante que o modal feche ao sair do FS
            }
        }

        function showFullscreenModal(tab) {
            const modal = document.getElementById('fullscreenModal');
            const content = document.getElementById('fullscreenModalContent');
            modal.classList.remove('hidden');
            modal.classList.add('flex');
            
            const tableContainer = document.getElementById('leaderboardContainer');
            const playoffContainer = document.getElementById('playoffContainer');

            // Limpa conteúdo anterior
            content.innerHTML = '';

            if (tab === 'table') {
                // Clona a estrutura da tabela
                content.innerHTML = tableContainer.innerHTML;
                // Renomeia o ID do tbody *dentro do modal*
                const newTbody = content.querySelector('tbody');
                if(newTbody) newTbody.id = 'leaderboardBody_fs';
                renderLeaderboard(); // Renderiza dados no novo tbody
            } else {
                // Clona a estrutura do playoff
                content.innerHTML = playoffContainer.innerHTML;
                 // Renomeia o ID do bracket *dentro do modal*
                const newBracket = content.querySelector('#playoffBracket');
                if(newBracket) newBracket.id = 'playoffBracket_fs';
                renderBracket(); // Renderiza dados no novo bracket
            }
        }

        function hideFullscreenModal() {
            const modal = document.getElementById('fullscreenModal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
            const content = document.getElementById('fullscreenModalContent');
            content.innerHTML = ''; // Limpa para não ter IDs duplicados
        }


        // --- FUNÇÕES DE RENDER ATUALIZADAS ---

        function renderLeaderboard() {
            const sorted = [...state.teams].sort((a,b)=>b.points-a.points || b.wins-a.wins);
            
            // Renderizar na aba principal
            const b = document.getElementById('leaderboardBody');
            b.innerHTML = '';
            sorted.forEach((t,i) => createLeaderboardRow(b, t, i));

            // Renderizar no modal de FS, se ele existir
            const b_fs = document.getElementById('leaderboardBody_fs');
            if (b_fs) {
                b_fs.innerHTML = '';
                sorted.forEach((t,i) => createLeaderboardRow(b_fs, t, i));
            }
        }
        
        function createLeaderboardRow(tbody, team, index) {
            const row = document.createElement('tr');
            const color = index<8 ? 'bg-green-500/10' : (index>=16 ? 'bg-red-500/10' : '');
            row.className = `border-b border-gray-800 ${color}`;
            row.innerHTML = `
                <td class="px-3 py-3 text-center text-gray-500 font-mono">${index+1}</td>
                <td class="px-2 py-2 flex items-center gap-2 font-bold text-gray-300">
                    <div class="w-3 h-3 rounded-full" style="background:${team.color}; border: 1px solid ${team.stroke || 'transparent'}"></div>${team.name}
                </td>
                <td class="px-2 py-2 text-right text-yellow-500 font-mono font-bold">${team.points}</td>
                <td class="px-2 py-2 text-center text-gray-500 text-xs">${team.wins}</td>`;
            tbody.appendChild(row);
        }

        function renderBracket() {
            // Renderizar na aba principal
            const div = document.getElementById('playoffBracket');
            div.innerHTML = '';
            renderBracketContent(div);

            // Renderizar no modal de FS, se ele existir
            const div_fs = document.getElementById('playoffBracket_fs');
            if (div_fs) {
                div_fs.innerHTML = '';
                renderBracketContent(div_fs);
            }
        }
        
        function renderBracketContent(container) {
            if (!container) return; // Segurança
            const rounds = ['Quartas', 'Semi', 'Final'];
            rounds.forEach(r => {
                const ms = state.playoff.bracket.filter(m => m.round === r);
                if(!ms.length) return;
                const title = document.createElement('div');
                title.className = "text-center text-[10px] font-bold text-gray-500 uppercase tracking-widest mb-2 mt-2";
                title.innerText = r;
                container.appendChild(title);
                ms.forEach(m => {
                    const isCur = !m.winner && state.playoff.bracket[state.playoff.matchIdx] === m;
                    const card = document.createElement('div');
                    card.className = `bg-gray-800 p-3 rounded mb-2 border ${isCur ? 'border-yellow-500 ring-1 ring-yellow-500' : 'border-gray-700'}`;
                    const t1=state.teams[m.p1], t2=state.teams[m.p2];
                    
                    // CORRIGIDO: `state.playof.scores` para `state.playoff.scores`
                    card.innerHTML = `
                        <div class="flex justify-between text-xs mb-2 items-center"><span class="${m.winner===m.p1?'text-green-400 font-bold':''} flex items-center gap-2"><div class="w-2 h-2 rounded-full" style="background:${t1.color}"></div>${t1.name}</span>${isCur?`<span class="bg-yellow-600 text-black px-1 rounded font-bold">${state.playoff.scores[0]}</span>`:(m.winner===m.p1?'✓':'')}</div>
                        <div class="flex justify-between text-xs items-center"><span class="${m.winner===m.p2?'text-green-400 font-bold':''} flex items-center gap-2"><div class="w-2 h-2 rounded-full" style="background:${t2.color}"></div>${t2.name}</span>${isCur?`<span class="bg-yellow-600 text-black px-1 rounded font-bold">${state.playoff.scores[1]}</span>`:(m.winner===m.p2?'✓':'')}</div>`;
                    container.appendChild(card);
                });
            });
        }

        init();
    </script>
</body>
</html>